diff -aNur qemu-2.6.1-orig/target-i386/cpu.c qemu-2.6.1-v4/target-i386/cpu.c
--- qemu-2.6.1-orig/target-i386/cpu.c	2019-04-25 20:08:53.988937331 +0800
+++ qemu-2.6.1-v4/target-i386/cpu.c	2019-04-26 17:06:07.037109440 +0800
@@ -157,7 +157,32 @@
 #define L2_ITLB_4K_ASSOC       4
 #define L2_ITLB_4K_ENTRIES   512
 
-
+/* CPUID Leaf 0x14 constants: */							//pt
+#define INTEL_PT_MAX_SUBLEAF     0x1							//pt
+/*											//pt
+ * bit[00]: IA32_RTIT_CTL.CR3 filter can be set to 1 and IA32_RTIT_CR3_MATCH		//pt
+ *          MSR can be accessed;							//pt
+ * bit[01]: Support Configurable PSB and Cycle-Accurate Mode;				//pt
+ * bit[02]: Support IP Filtering, TraceStop filtering, and preservation			//pt
+ *          of Intel PT MSRs across warm reset;						//pt
+ * bit[03]: Support MTC timing packet and suppression of COFI-based packets;		//pt
+ */											//pt
+#define INTEL_PT_MINIMAL_EBX     0xf							//pt
+/*											//pt
+ * bit[00]: Tracing can be enabled with IA32_RTIT_CTL.ToPA = 1 and			//pt
+ *          IA32_RTIT_OUTPUT_BASE and IA32_RTIT_OUTPUT_MASK_PTRS MSRs can be		//pt
+ *          accessed;									//pt
+ * bit[01]: ToPA tables can hold any number of output entries, up to the		//pt
+ *          maximum allowed by the MaskOrTableOffset field of				//pt
+ *          IA32_RTIT_OUTPUT_MASK_PTRS;							//pt
+ * bit[02]: Support Single-Range Output scheme;						//pt
+ */											//pt
+#define INTEL_PT_MINIMAL_ECX     0x7							//pt
+#define INTEL_PT_ADDR_RANGES_NUM 0x2 /* Number of configurable address ranges */	//pt
+#define INTEL_PT_ADDR_RANGES_NUM_MASK 0x3						//pt
+#define INTEL_PT_MTC_BITMAP      (0x0249 << 16) /* Support ART(0,3,6,9) */		//pt
+#define INTEL_PT_CYCLE_BITMAP    0x1fff         /* Support 0,2^(0~11) */		//pt
+#define INTEL_PT_PSB_BITMAP      (0x003f << 16) /* Support 2K,4K,8K,16K,32K,64K */	//pt
 
 static void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
                                      uint32_t vendor2, uint32_t vendor3)
@@ -257,8 +282,11 @@
 static const char *cpuid_7_0_ebx_feature_name[] = {
     "fsgsbase", "tsc_adjust", NULL, "bmi1", "hle", "avx2", NULL, "smep",
     "bmi2", "erms", "invpcid", "rtm", NULL, NULL, "mpx", NULL,
-    "avx512f", NULL, "rdseed", "adx", "smap", NULL, "pcommit", "clflushopt",
-    "clwb", NULL, "avx512pf", "avx512er", "avx512cd", NULL, NULL, NULL,
+    "avx512f", NULL, "rdseed", "adx", "smap", NULL, "pcommit", "clflushopt",			//pt
+    //"avx512f", "avx512dq", "rdseed", "adx", "smap", "avx512ifma", "pcommit", "clflushopt",	//pt
+    //"clwb", NULL, "avx512pf", "avx512er", "avx512cd", NULL, NULL, NULL,			//pt
+    //"clwb", "intel-pt", "avx512pf", "avx512er", "avx512cd", "sha-ni", "avx512bw", "avx512vl",	//pt
+    "clwb", "intel-pt", "avx512pf", "avx512er", "avx512cd", NULL, NULL, NULL,			//pt
 };
 
 static const char *cpuid_7_0_ecx_feature_name[] = {
@@ -2096,6 +2124,34 @@
         }
     }
 
+    if ((env->features[FEAT_7_0_EBX] & CPUID_7_0_EBX_INTEL_PT) &&				//pt
+        kvm_enabled()) {									//pt
+        KVMState *s = CPU(cpu)->kvm_state;							//pt
+        uint32_t eax_0 = kvm_arch_get_supported_cpuid(s, 0x14, 0, R_EAX);			//pt
+        uint32_t ebx_0 = kvm_arch_get_supported_cpuid(s, 0x14, 0, R_EBX);			//pt
+        uint32_t ecx_0 = kvm_arch_get_supported_cpuid(s, 0x14, 0, R_ECX);			//pt
+        uint32_t eax_1 = kvm_arch_get_supported_cpuid(s, 0x14, 1, R_EAX);			//pt
+        uint32_t ebx_1 = kvm_arch_get_supported_cpuid(s, 0x14, 1, R_EBX);			//pt
+												//pt
+        if (!eax_0 ||										//pt
+           ((ebx_0 & INTEL_PT_MINIMAL_EBX) != INTEL_PT_MINIMAL_EBX) ||				//pt
+           ((ecx_0 & INTEL_PT_MINIMAL_ECX) != INTEL_PT_MINIMAL_ECX) ||				//pt
+           ((eax_1 & INTEL_PT_MTC_BITMAP) != INTEL_PT_MTC_BITMAP) ||				//pt
+           ((eax_1 & INTEL_PT_ADDR_RANGES_NUM_MASK) <						//pt
+                                           INTEL_PT_ADDR_RANGES_NUM) ||				//pt
+           ((ebx_1 & (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP)) !=				//pt
+                (INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP))) {				//pt
+            /*											//pt
+             * Processor Trace capabilities aren't configurable, so if the			//pt
+             * host can't emulate the capabilities we report on					//pt
+             * cpu_x86_cpuid(), intel-pt can't be enabled on the current host.			//pt
+             */											//pt
+            env->features[FEAT_7_0_EBX] &= ~CPUID_7_0_EBX_INTEL_PT;				//pt
+            cpu->filtered_features[FEAT_7_0_EBX] |= CPUID_7_0_EBX_INTEL_PT;			//pt
+            rv = 1;										//pt
+        }											//pt
+    }												//pt
+
     return rv;
 }
 
@@ -2509,6 +2565,27 @@
         }
         break;
     }
+    case 0x14: {									//pt
+        /* Intel Processor Trace Enumeration */						//pt
+        *eax = 0;									//pt
+        *ebx = 0;									//pt
+        *ecx = 0;									//pt
+        *edx = 0;									//pt
+        if (!(env->features[FEAT_7_0_EBX] & CPUID_7_0_EBX_INTEL_PT) ||			//pt
+            !kvm_enabled()) {								//pt
+            break;									//pt
+        }										//pt
+											//pt
+        if (count == 0) {								//pt
+            *eax = INTEL_PT_MAX_SUBLEAF;						//pt
+            *ebx = INTEL_PT_MINIMAL_EBX;						//pt
+            *ecx = INTEL_PT_MINIMAL_ECX;						//pt
+        } else if (count == 1) {							//pt
+            *eax = INTEL_PT_MTC_BITMAP | INTEL_PT_ADDR_RANGES_NUM;			//pt
+            *ebx = INTEL_PT_PSB_BITMAP | INTEL_PT_CYCLE_BITMAP;				//pt
+        }										//pt
+        break;										//pt
+    }											//pt
     case 0x80000000:
         *eax = env->cpuid_xlevel;
         *ebx = env->cpuid_vendor1;
diff -aNur qemu-2.6.1-orig/target-i386/cpu.h qemu-2.6.1-v4/target-i386/cpu.h
--- qemu-2.6.1-orig/target-i386/cpu.h	2019-04-25 20:08:53.988937331 +0800
+++ qemu-2.6.1-v4/target-i386/cpu.h	2019-04-26 15:57:13.465006946 +0800
@@ -385,6 +385,21 @@
 #define MSR_MC0_ADDR                    0x402
 #define MSR_MC0_MISC                    0x403
 
+#define MSR_IA32_RTIT_OUTPUT_BASE       0x560				//pt
+#define MSR_IA32_RTIT_OUTPUT_MASK       0x561				//pt
+#define MSR_IA32_RTIT_CTL               0x570				//pt
+#define MSR_IA32_RTIT_STATUS            0x571				//pt
+#define MSR_IA32_RTIT_CR3_MATCH         0x572				//pt
+#define MSR_IA32_RTIT_ADDR0_A           0x580				//pt
+#define MSR_IA32_RTIT_ADDR0_B           0x581				//pt
+#define MSR_IA32_RTIT_ADDR1_A           0x582				//pt
+#define MSR_IA32_RTIT_ADDR1_B           0x583				//pt
+#define MSR_IA32_RTIT_ADDR2_A           0x584				//pt
+#define MSR_IA32_RTIT_ADDR2_B           0x585				//pt
+#define MSR_IA32_RTIT_ADDR3_A           0x586				//pt
+#define MSR_IA32_RTIT_ADDR3_B           0x587				//pt
+#define MAX_RTIT_ADDRS                  8				//pt
+
 #define MSR_EFER                        0xc0000080
 
 #define MSR_EFER_SCE   (1 << 0)
@@ -601,6 +616,7 @@
 #define CPUID_7_0_EBX_PCOMMIT  (1U << 22) /* Persistent Commit */
 #define CPUID_7_0_EBX_CLFLUSHOPT (1U << 23) /* Flush a Cache Line Optimized */
 #define CPUID_7_0_EBX_CLWB     (1U << 24) /* Cache Line Write Back */
+#define CPUID_7_0_EBX_INTEL_PT (1U << 25) /* Intel Processor Trace */			//pt
 #define CPUID_7_0_EBX_AVX512PF (1U << 26) /* AVX-512 Prefetch */
 #define CPUID_7_0_EBX_AVX512ER (1U << 27) /* AVX-512 Exponential and Reciprocal */
 #define CPUID_7_0_EBX_AVX512CD (1U << 28) /* AVX-512 Conflict Detection */
@@ -951,6 +967,13 @@
     uint64_t msr_hv_stimer_config[HV_SYNIC_STIMER_COUNT];
     uint64_t msr_hv_stimer_count[HV_SYNIC_STIMER_COUNT];
 
+    uint64_t msr_rtit_ctrl;						//pt
+    uint64_t msr_rtit_status;						//pt
+    uint64_t msr_rtit_output_base;					//pt
+    uint64_t msr_rtit_output_mask;					//pt
+    uint64_t msr_rtit_cr3_match;					//pt
+    uint64_t msr_rtit_addrs[MAX_RTIT_ADDRS];				//pt
+
     /* exception/interrupt handling */
     int error_code;
     int exception_is_int;
diff -aNur qemu-2.6.1-orig/target-i386/kvm.c qemu-2.6.1-v4/target-i386/kvm.c
--- qemu-2.6.1-orig/target-i386/kvm.c	2019-04-25 20:08:53.988937331 +0800
+++ qemu-2.6.1-v4/target-i386/kvm.c	2019-04-26 17:03:43.481105881 +0800
@@ -774,6 +774,29 @@
                 c = &cpuid_data.entries[cpuid_i++];
             }
             break;
+        case 0x14: {									//pt
+            uint32_t times;								//pt
+											//pt
+            c->function = i;								//pt
+            c->index = 0;								//pt
+            c->flags = KVM_CPUID_FLAG_SIGNIFCANT_INDEX;					//pt
+            cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);		//pt
+            times = c->eax;								//pt
+											//pt
+            for (j = 1; j <= times; ++j) {						//pt
+                if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {					//pt
+                    fprintf(stderr, "cpuid_data is full, no space for "			//pt
+                                "cpuid(eax:0x14,ecx:0x%x)\n", j);			//pt
+                    abort();								//pt
+                }									//pt
+                c = &cpuid_data.entries[cpuid_i++];					//pt
+                c->function = i;							//pt
+                c->index = j;								//pt
+                c->flags = KVM_CPUID_FLAG_SIGNIFCANT_INDEX;				//pt
+                cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);		//pt
+            }										//pt
+            break;									//pt
+        }										//pt
         default:
             c->function = i;
             c->flags = 0;
@@ -1688,6 +1711,26 @@
             }
         }
 
+        if (env->features[FEAT_7_0_EBX] & CPUID_7_0_EBX_INTEL_PT) {			//pt
+            int addr_num = kvm_arch_get_supported_cpuid(kvm_state,			//pt
+                                                    0x14, 1, R_EAX) & 0x7;		//pt
+											//pt
+            kvm_msr_entry_set(&msrs[n++], MSR_IA32_RTIT_CTL,				//pt
+                            env->msr_rtit_ctrl);					//pt
+            kvm_msr_entry_set(&msrs[n++], MSR_IA32_RTIT_STATUS,				//pt
+                            env->msr_rtit_status);					//pt
+            kvm_msr_entry_set(&msrs[n++], MSR_IA32_RTIT_OUTPUT_BASE,			//pt
+                            env->msr_rtit_output_base);					//pt
+            kvm_msr_entry_set(&msrs[n++], MSR_IA32_RTIT_OUTPUT_MASK,			//pt
+                            env->msr_rtit_output_mask);					//pt
+            kvm_msr_entry_set(&msrs[n++], MSR_IA32_RTIT_CR3_MATCH,			//pt
+                            env->msr_rtit_cr3_match);					//pt
+            for (i = 0; i < addr_num; i++) {						//pt
+                kvm_msr_entry_set(&msrs[n++], MSR_IA32_RTIT_ADDR0_A + i,		//pt
+                            env->msr_rtit_addrs[i]);					//pt
+            }										//pt
+        }										//pt
+
         /* Note: MSR_IA32_FEATURE_CONTROL is written separately, see
          *       kvm_put_msr_feature_control. */
     }
@@ -1966,7 +2009,6 @@
         msrs[n++].index = MSR_IA32_XSS;
     }
 
-
     if (!env->tsc_valid) {
         msrs[n++].index = MSR_IA32_TSC;
         env->tsc_valid = !runstate_is_running();
@@ -2071,6 +2113,20 @@
         }
     }
 
+    if (env->features[FEAT_7_0_EBX] & CPUID_7_0_EBX_INTEL_PT) {				//pt
+        int addr_num =									//pt
+            kvm_arch_get_supported_cpuid(kvm_state, 0x14, 1, R_EAX) & 0x7;		//pt
+											//pt
+        msrs[n++].index = MSR_IA32_RTIT_CTL;						//pt
+        msrs[n++].index = MSR_IA32_RTIT_STATUS;						//pt
+        msrs[n++].index = MSR_IA32_RTIT_OUTPUT_BASE;					//pt
+        msrs[n++].index = MSR_IA32_RTIT_OUTPUT_MASK;					//pt
+        msrs[n++].index = MSR_IA32_RTIT_CR3_MATCH;					//pt
+        for (i = 0; i < addr_num; i++) {						//pt
+            msrs[n++].index = MSR_IA32_RTIT_ADDR0_A + i;				//pt
+        }										//pt
+    }											//pt
+
     msr_data.info = (struct kvm_msrs) {
         .nmsrs = n,
     };
@@ -2281,6 +2337,24 @@
                 env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;
             }
             break;
+        case MSR_IA32_RTIT_CTL:								//pt
+            env->msr_rtit_ctrl = msrs[i].data;						//pt
+            break;									//pt
+        case MSR_IA32_RTIT_STATUS:							//pt
+            env->msr_rtit_status = msrs[i].data;					//pt
+            break;									//pt
+        case MSR_IA32_RTIT_OUTPUT_BASE:							//pt
+            env->msr_rtit_output_base = msrs[i].data;					//pt
+            break;									//pt
+        case MSR_IA32_RTIT_OUTPUT_MASK:							//pt
+            env->msr_rtit_output_mask = msrs[i].data;					//pt
+            break;									//pt
+        case MSR_IA32_RTIT_CR3_MATCH:							//pt
+            env->msr_rtit_cr3_match = msrs[i].data;					//pt
+            break;									//pt
+        case MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:				//pt
+            env->msr_rtit_addrs[index - MSR_IA32_RTIT_ADDR0_A] = msrs[i].data;		//pt
+            break;									//pt
         }
     }
 
diff -aNur qemu-2.6.1-orig/target-i386/machine.c qemu-2.6.1-v4/target-i386/machine.c
--- qemu-2.6.1-orig/target-i386/machine.c	2019-04-25 20:08:53.988937331 +0800
+++ qemu-2.6.1-v4/target-i386/machine.c	2019-04-26 16:01:57.345013985 +0800
@@ -890,6 +890,43 @@
     }
 };
 
+static bool intel_pt_enable_needed(void *opaque)				//pt
+{										//pt
+    X86CPU *cpu = opaque;							//pt
+    CPUX86State *env = &cpu->env;						//pt
+    int i;									//pt
+										//pt
+    if (env->msr_rtit_ctrl || env->msr_rtit_status ||				//pt
+        env->msr_rtit_output_base || env->msr_rtit_output_mask ||		//pt
+        env->msr_rtit_cr3_match) {						//pt
+        return true;								//pt
+    }										//pt
+										//pt
+    for (i = 0; i < MAX_RTIT_ADDRS; i++) {					//pt
+        if (env->msr_rtit_addrs[i]) {						//pt
+            return true;							//pt
+        }									//pt
+    }										//pt
+										//pt
+    return false;								//pt
+}										//pt
+										//pt
+static const VMStateDescription vmstate_msr_intel_pt = {			//pt
+    .name = "cpu/intel_pt",							//pt
+    .version_id = 1,								//pt
+    .minimum_version_id = 1,							//pt
+    .needed = intel_pt_enable_needed,						//pt
+    .fields = (VMStateField[]) {						//pt
+        VMSTATE_UINT64(env.msr_rtit_ctrl, X86CPU),				//pt
+        VMSTATE_UINT64(env.msr_rtit_status, X86CPU),				//pt
+        VMSTATE_UINT64(env.msr_rtit_output_base, X86CPU),			//pt
+        VMSTATE_UINT64(env.msr_rtit_output_mask, X86CPU),			//pt
+        VMSTATE_UINT64(env.msr_rtit_cr3_match, X86CPU),				//pt
+        VMSTATE_UINT64_ARRAY(env.msr_rtit_addrs, X86CPU, MAX_RTIT_ADDRS),	//pt
+        VMSTATE_END_OF_LIST()							//pt
+    }										//pt
+};										//pt
+
 VMStateDescription vmstate_x86_cpu = {
     .name = "cpu",
     .version_id = 12,
@@ -1016,6 +1053,7 @@
 #ifdef TARGET_X86_64
         &vmstate_pkru,
 #endif
+        &vmstate_msr_intel_pt,							//pt
         NULL
     }
 };
